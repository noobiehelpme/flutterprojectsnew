// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'calculator_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$CalculatorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculatorEventCopyWith<$Res> {
  factory $CalculatorEventCopyWith(
          CalculatorEvent value, $Res Function(CalculatorEvent) then) =
      _$CalculatorEventCopyWithImpl<$Res, CalculatorEvent>;
}

/// @nodoc
class _$CalculatorEventCopyWithImpl<$Res, $Val extends CalculatorEvent>
    implements $CalculatorEventCopyWith<$Res> {
  _$CalculatorEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_FindResultCopyWith<$Res> {
  factory _$$_FindResultCopyWith(
          _$_FindResult value, $Res Function(_$_FindResult) then) =
      __$$_FindResultCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FindResultCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_FindResult>
    implements _$$_FindResultCopyWith<$Res> {
  __$$_FindResultCopyWithImpl(
      _$_FindResult _value, $Res Function(_$_FindResult) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FindResult implements _FindResult {
  const _$_FindResult();

  @override
  String toString() {
    return 'CalculatorEvent.findResult()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_FindResult);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return findResult();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return findResult?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (findResult != null) {
      return findResult();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return findResult(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return findResult?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (findResult != null) {
      return findResult(this);
    }
    return orElse();
  }
}

abstract class _FindResult implements CalculatorEvent {
  const factory _FindResult() = _$_FindResult;
}

/// @nodoc
abstract class _$$_DivisionCopyWith<$Res> {
  factory _$$_DivisionCopyWith(
          _$_Division value, $Res Function(_$_Division) then) =
      __$$_DivisionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_DivisionCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Division>
    implements _$$_DivisionCopyWith<$Res> {
  __$$_DivisionCopyWithImpl(
      _$_Division _value, $Res Function(_$_Division) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Division implements _Division {
  const _$_Division();

  @override
  String toString() {
    return 'CalculatorEvent.division()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Division);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return division();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return division?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (division != null) {
      return division();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return division(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return division?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (division != null) {
      return division(this);
    }
    return orElse();
  }
}

abstract class _Division implements CalculatorEvent {
  const factory _Division() = _$_Division;
}

/// @nodoc
abstract class _$$_AdditionCopyWith<$Res> {
  factory _$$_AdditionCopyWith(
          _$_Addition value, $Res Function(_$_Addition) then) =
      __$$_AdditionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AdditionCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Addition>
    implements _$$_AdditionCopyWith<$Res> {
  __$$_AdditionCopyWithImpl(
      _$_Addition _value, $Res Function(_$_Addition) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Addition implements _Addition {
  const _$_Addition();

  @override
  String toString() {
    return 'CalculatorEvent.addition()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Addition);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return addition();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return addition?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (addition != null) {
      return addition();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return addition(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return addition?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (addition != null) {
      return addition(this);
    }
    return orElse();
  }
}

abstract class _Addition implements CalculatorEvent {
  const factory _Addition() = _$_Addition;
}

/// @nodoc
abstract class _$$_MultipleCopyWith<$Res> {
  factory _$$_MultipleCopyWith(
          _$_Multiple value, $Res Function(_$_Multiple) then) =
      __$$_MultipleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_MultipleCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Multiple>
    implements _$$_MultipleCopyWith<$Res> {
  __$$_MultipleCopyWithImpl(
      _$_Multiple _value, $Res Function(_$_Multiple) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Multiple implements _Multiple {
  const _$_Multiple();

  @override
  String toString() {
    return 'CalculatorEvent.multiple()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Multiple);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return multiple();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return multiple?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (multiple != null) {
      return multiple();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return multiple(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return multiple?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (multiple != null) {
      return multiple(this);
    }
    return orElse();
  }
}

abstract class _Multiple implements CalculatorEvent {
  const factory _Multiple() = _$_Multiple;
}

/// @nodoc
abstract class _$$_SubstractionCopyWith<$Res> {
  factory _$$_SubstractionCopyWith(
          _$_Substraction value, $Res Function(_$_Substraction) then) =
      __$$_SubstractionCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SubstractionCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Substraction>
    implements _$$_SubstractionCopyWith<$Res> {
  __$$_SubstractionCopyWithImpl(
      _$_Substraction _value, $Res Function(_$_Substraction) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Substraction implements _Substraction {
  const _$_Substraction();

  @override
  String toString() {
    return 'CalculatorEvent.substractoin()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Substraction);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return substractoin();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return substractoin?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (substractoin != null) {
      return substractoin();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return substractoin(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return substractoin?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (substractoin != null) {
      return substractoin(this);
    }
    return orElse();
  }
}

abstract class _Substraction implements CalculatorEvent {
  const factory _Substraction() = _$_Substraction;
}

/// @nodoc
abstract class _$$_ModulusCopyWith<$Res> {
  factory _$$_ModulusCopyWith(
          _$_Modulus value, $Res Function(_$_Modulus) then) =
      __$$_ModulusCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ModulusCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Modulus>
    implements _$$_ModulusCopyWith<$Res> {
  __$$_ModulusCopyWithImpl(_$_Modulus _value, $Res Function(_$_Modulus) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Modulus implements _Modulus {
  const _$_Modulus();

  @override
  String toString() {
    return 'CalculatorEvent.modulus()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Modulus);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return modulus();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return modulus?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (modulus != null) {
      return modulus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return modulus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return modulus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (modulus != null) {
      return modulus(this);
    }
    return orElse();
  }
}

abstract class _Modulus implements CalculatorEvent {
  const factory _Modulus() = _$_Modulus;
}

/// @nodoc
abstract class _$$_ClearCopyWith<$Res> {
  factory _$$_ClearCopyWith(_$_Clear value, $Res Function(_$_Clear) then) =
      __$$_ClearCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_ClearCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_Clear>
    implements _$$_ClearCopyWith<$Res> {
  __$$_ClearCopyWithImpl(_$_Clear _value, $Res Function(_$_Clear) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Clear implements _Clear {
  const _$_Clear();

  @override
  String toString() {
    return 'CalculatorEvent.clear()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Clear);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return clear();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return clear?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return clear(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return clear?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (clear != null) {
      return clear(this);
    }
    return orElse();
  }
}

abstract class _Clear implements CalculatorEvent {
  const factory _Clear() = _$_Clear;
}

/// @nodoc
abstract class _$$_UserInputActionCopyWith<$Res> {
  factory _$$_UserInputActionCopyWith(
          _$_UserInputAction value, $Res Function(_$_UserInputAction) then) =
      __$$_UserInputActionCopyWithImpl<$Res>;
  @useResult
  $Res call({num inputReader});
}

/// @nodoc
class __$$_UserInputActionCopyWithImpl<$Res>
    extends _$CalculatorEventCopyWithImpl<$Res, _$_UserInputAction>
    implements _$$_UserInputActionCopyWith<$Res> {
  __$$_UserInputActionCopyWithImpl(
      _$_UserInputAction _value, $Res Function(_$_UserInputAction) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inputReader = null,
  }) {
    return _then(_$_UserInputAction(
      inputReader: null == inputReader
          ? _value.inputReader
          : inputReader // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc

class _$_UserInputAction implements _UserInputAction {
  const _$_UserInputAction({required this.inputReader});

  @override
  final num inputReader;

  @override
  String toString() {
    return 'CalculatorEvent.userInputAction(inputReader: $inputReader)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UserInputAction &&
            (identical(other.inputReader, inputReader) ||
                other.inputReader == inputReader));
  }

  @override
  int get hashCode => Object.hash(runtimeType, inputReader);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UserInputActionCopyWith<_$_UserInputAction> get copyWith =>
      __$$_UserInputActionCopyWithImpl<_$_UserInputAction>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() findResult,
    required TResult Function() division,
    required TResult Function() addition,
    required TResult Function() multiple,
    required TResult Function() substractoin,
    required TResult Function() modulus,
    required TResult Function() clear,
    required TResult Function(num inputReader) userInputAction,
  }) {
    return userInputAction(inputReader);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? findResult,
    TResult? Function()? division,
    TResult? Function()? addition,
    TResult? Function()? multiple,
    TResult? Function()? substractoin,
    TResult? Function()? modulus,
    TResult? Function()? clear,
    TResult? Function(num inputReader)? userInputAction,
  }) {
    return userInputAction?.call(inputReader);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? findResult,
    TResult Function()? division,
    TResult Function()? addition,
    TResult Function()? multiple,
    TResult Function()? substractoin,
    TResult Function()? modulus,
    TResult Function()? clear,
    TResult Function(num inputReader)? userInputAction,
    required TResult orElse(),
  }) {
    if (userInputAction != null) {
      return userInputAction(inputReader);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FindResult value) findResult,
    required TResult Function(_Division value) division,
    required TResult Function(_Addition value) addition,
    required TResult Function(_Multiple value) multiple,
    required TResult Function(_Substraction value) substractoin,
    required TResult Function(_Modulus value) modulus,
    required TResult Function(_Clear value) clear,
    required TResult Function(_UserInputAction value) userInputAction,
  }) {
    return userInputAction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FindResult value)? findResult,
    TResult? Function(_Division value)? division,
    TResult? Function(_Addition value)? addition,
    TResult? Function(_Multiple value)? multiple,
    TResult? Function(_Substraction value)? substractoin,
    TResult? Function(_Modulus value)? modulus,
    TResult? Function(_Clear value)? clear,
    TResult? Function(_UserInputAction value)? userInputAction,
  }) {
    return userInputAction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FindResult value)? findResult,
    TResult Function(_Division value)? division,
    TResult Function(_Addition value)? addition,
    TResult Function(_Multiple value)? multiple,
    TResult Function(_Substraction value)? substractoin,
    TResult Function(_Modulus value)? modulus,
    TResult Function(_Clear value)? clear,
    TResult Function(_UserInputAction value)? userInputAction,
    required TResult orElse(),
  }) {
    if (userInputAction != null) {
      return userInputAction(this);
    }
    return orElse();
  }
}

abstract class _UserInputAction implements CalculatorEvent {
  const factory _UserInputAction({required final num inputReader}) =
      _$_UserInputAction;

  num get inputReader;
  @JsonKey(ignore: true)
  _$$_UserInputActionCopyWith<_$_UserInputAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CalculatorState {
  num get result => throw _privateConstructorUsedError;
  num get userinput => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CalculatorStateCopyWith<CalculatorState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CalculatorStateCopyWith<$Res> {
  factory $CalculatorStateCopyWith(
          CalculatorState value, $Res Function(CalculatorState) then) =
      _$CalculatorStateCopyWithImpl<$Res, CalculatorState>;
  @useResult
  $Res call({num result, num userinput});
}

/// @nodoc
class _$CalculatorStateCopyWithImpl<$Res, $Val extends CalculatorState>
    implements $CalculatorStateCopyWith<$Res> {
  _$CalculatorStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
    Object? userinput = null,
  }) {
    return _then(_value.copyWith(
      result: null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as num,
      userinput: null == userinput
          ? _value.userinput
          : userinput // ignore: cast_nullable_to_non_nullable
              as num,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_CalculatorStateCopyWith<$Res>
    implements $CalculatorStateCopyWith<$Res> {
  factory _$$_CalculatorStateCopyWith(
          _$_CalculatorState value, $Res Function(_$_CalculatorState) then) =
      __$$_CalculatorStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({num result, num userinput});
}

/// @nodoc
class __$$_CalculatorStateCopyWithImpl<$Res>
    extends _$CalculatorStateCopyWithImpl<$Res, _$_CalculatorState>
    implements _$$_CalculatorStateCopyWith<$Res> {
  __$$_CalculatorStateCopyWithImpl(
      _$_CalculatorState _value, $Res Function(_$_CalculatorState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? result = null,
    Object? userinput = null,
  }) {
    return _then(_$_CalculatorState(
      result: null == result
          ? _value.result
          : result // ignore: cast_nullable_to_non_nullable
              as num,
      userinput: null == userinput
          ? _value.userinput
          : userinput // ignore: cast_nullable_to_non_nullable
              as num,
    ));
  }
}

/// @nodoc

class _$_CalculatorState implements _CalculatorState {
  const _$_CalculatorState({required this.result, required this.userinput});

  @override
  final num result;
  @override
  final num userinput;

  @override
  String toString() {
    return 'CalculatorState(result: $result, userinput: $userinput)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_CalculatorState &&
            (identical(other.result, result) || other.result == result) &&
            (identical(other.userinput, userinput) ||
                other.userinput == userinput));
  }

  @override
  int get hashCode => Object.hash(runtimeType, result, userinput);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_CalculatorStateCopyWith<_$_CalculatorState> get copyWith =>
      __$$_CalculatorStateCopyWithImpl<_$_CalculatorState>(this, _$identity);
}

abstract class _CalculatorState implements CalculatorState {
  const factory _CalculatorState(
      {required final num result,
      required final num userinput}) = _$_CalculatorState;

  @override
  num get result;
  @override
  num get userinput;
  @override
  @JsonKey(ignore: true)
  _$$_CalculatorStateCopyWith<_$_CalculatorState> get copyWith =>
      throw _privateConstructorUsedError;
}
